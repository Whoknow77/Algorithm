# 알고리즘

## 1주차

**수학적 귀납법을 통해 재귀 증명**(매우중요)

==> 직관과 충돌하는 부분이 있음!!



우선 명제 P -> Q의 의미를 알아야 한다.

P가 참, Q가 참 -> 전체는 참
P가 참, Q가 거짓 -> 전체는 거짓
P가 거짓 -> 전체는 거짓

P가 거짓일때는 Vacuous라고 해서 항상 전체가 참인 경우이다. 이 부분이 직관과 충돌하지만 예시를 들어보면 편하다.

시험을 100점 받으면 치킨을 사준다(P->Q)에서

시험을 100점 받았는데도 치킨을 못 먹은 경우는 확실히 F이다.

하지만 시험을 못봤으면 치킨을 먹든 못 먹든 상관이 없어져서 이부분이 Vacuous라 하는데 False는 확실히 아니고 True라고 하기도 애매해서 Vacuous라 부른다. 근데 이 부분을 그냥 Vacuous True라고 불러서 True로 치는 것이다.

수학적 귀납법의 큰 틀은 

(1) Base : P(1)이 참이고

(2) Step : P(n-1) -> P(n)이 참이면

(3) Result : P(n)은 모든 자연수 n에 대해서 참이다.

**여기서 P(n-1)이 참이라고 가정하는 이유는 뭘까? 만약 거짓이면?**

이 부분에서 Vacuous True가 사용된다.

P(n-1)이 거짓일때는 전체가 참이므로 애초에 논의할 의미가 없다.

따라서 P(n-1)이 참인 경우에만 논의해야하며, 이를 참이라 믿는 것이다.

**총합을 구하는 재귀 함수**
```
int sum(int x){
    if(x==0){
        return 0;
    }
    return x + sum(x-1);
}
```
보통의 이러한 재귀 함수를 보면 그 다음단계로 호출하는 과정을 생각하며 계속 굴처럼 파고 들어가서 이해를 한다.

**1주차의 가장 큰 의미는 이러한 과정을 안하기 위해서 재귀호출이 그냥 정답을 return한다고 믿자는 것이다.**

사실 재귀함수가 조금만 복잡해져도 그 함수를 들어가서 이해하는 것은 매우 어려운 일에 해당하고 교수님 말씀으로는 이런식으로 이해하는 사람이 세상에 그렇게 많지 않다고 한다.. 일단 난 절대 아님 ㅠ

아무튼 저 코드에서 Sum(x-1)을 보면 함수를 따라 들어가지 말고 1부터x-1까지의 합을 return한다고 믿으면 된다.

그럼 결론적으로 return x + sum(x-1)은 
1부터 x까지의 합을 리턴한다.

**Binary Search**

```
int search(int a[], int n, int x){ //배열, size, 찾을 값
    int l, r, m;
    l=0; // 맨 왼쪽 인덱스
    r=n-1; // 맨 오른쪽 인덱스
    while(l<=r){
 
        m=(l+r)/2; // l<=m<=r

        if(a[m]==x){
            return m;
        }

        else if(a[m]>x){
            r=m-1;
        }

        else{
            l=m+1;
        }
        return -1;
    }
}
```

**핵심**

1) m을 보고 a[m]>x이면 찾는 값 보다 a[m]이 오른쪽에 있으므로 오른쪽은 찾을 필요가 없다.-> l부터 m-1까지만 조사하자

    a[m]<x이면 찾는 값보다 a[m]이 왼쪽에 있으므로 왼쪽은 찾을 필요가 없다. -> m+1부터 r까지만 조사하자.

2) r이 l보다 작을 경우.. => 서로 교차한 상황
=> l부터 r까지의 배열이 0개 => 0개 중에 x가 있다? => x가 없다.

    세 개의 박스중에 고양이가 있다면 한 곳에 있다 ==> 고양이가 있는지 없는지 모른다.

    박스가 없다, 고양이가 있다면 박스 중에 한 곳에 있다 => 박스가 없으므로 고양이가 없다.

**증명**

Invariant : 불변(코드에서 잘 찾아야 함)

a[i] = x라면 l<=i<=r 이 항상 성립한다.

=> 찾고자 하는 값이 있다면 l과 r 사이에 존재한다.(l과 r이 바뀔때 항상 조건이 성립한다.)

이걸 깨뜨리는 코드는 존재하지 않는다.(집합조건을 깨뜨리는 코드)

따라서 a[i]=x인 i가 없다면 -1이 리턴된다 -> 루프 안에서 반드시 리턴된다

**Recursive Binary Search**

```
int search(int a[], int n , int x){
    int m;
    if(n==0){ // 배열 사이즈가 0이하면 없다는 것 
        return -1;
    }
    m=n/2;
    if(a[m]==x){
        return m; 
    }
    else if(a[m] > x){
        return search(a, m, x); // m개(0부터 m-1까지의 개수)
    }
    else{
        r = search(a+m+1, n-m-1, x); // 전체 n개에서 m+1개가 빠짐 n-(m+1) == n-m-1
        if(r==-1){
            return -1;
        }
        else{
            return r + m + 1;
        }
    }
}
```

**증명**

Base : n이 0인 경우, Vacuous true로 만족한다.

Step:
    
- case 1 :
  
    a[m]==x인 경우, m을 리턴하므로 성립


- case 2 :

    a[m]>x인 경우, 오른쪽을 무시, 즉 a[m+1], a[m+2], ..., a[n]이 모두 x보다 크므로 a[i]=x인 경우가 있다면 i는 0,1, ..., m-1 중 하나이다.

    따라서 return(a,m,x)에서 재귀함수로 성립한다고 믿으면 위 주장이 성립한다.


- case 3 : case2와 동일



**Selection Sort**

```
int sort(int a[], int n){
    int i, j, m, t;
    for(i=0; i<n; i++){
        m=i;
        for(j=i; j<n; j++){
            if(a[m]>a[j]){
                m=j;
            }
            t=a[i]; //swap
            a[i]=a[m];
            a[m]=t;
        }
    }
}
```


Sorting이 됐다는 증명을 어떻게?

입력 : a[0], a[1], ...

Sorting이 완료된 후 다음이 만족되어야 함

1) Sorting전의 a[0], a[1], ... a[n-1](sorting 전 집합) = b[0], b[1], ..., b[n-1](Sorting 후 집합)

2) b[0] < b[1] < ... < b[n-1]

## proof by Invariant

집합 조건을 깰 수 있는 코드가 없음

k번째 루프가 끝난 후에

**Invariant**(찾는데는 창의력을 요구함)

(1) a[0] < a[1] < ... < a[k-1] -> a[0] < a[1] < ... < a[n-1]

(2) if x > k-1 a[k-1] < a[x]

위 두개의 Invariant가 항상 성립한다는걸 증명하면 집합 조건을 깰 수 있는 코드는 없다와 (1),(2)가 사실이므로 Sorting이 증명된다.

Invariant가 항상 성립한다는건 수학적 귀납법으로 증명한다.

Base : k=0, (1), (2)가 null condition으로 true이다.(아무 것도 없으면 true => vacuous true )

Step : k번째 루프가 끝났을 때 Invariant가 성립한다면, k+1번째 루프가 끝났을때도 Invariant가 성립한다.

Invariant : k번째 루프가 끝난 후

(1) : a[0] > a[1] < ... < a[k-1]

(2) : if x > k-1 a[k-1] < a[x]

**a[k], ..., a[n-1]중 최소값을 a[k]로 옮김**

Invariant : k+1번째 루프가 끝난 후

(1) : a[0] > a[1] < ... < a[k-1] < a[k] (a[k]가 뭐든지간에 위의 (2)에의해 성립)

(2) : if x > k a[k] < a[x]


**Recursive Selection Sort**

```
int sort(int a[], int n){
    int j, m, t;
    if(n<=1){
        return;
    }
    m=0;
    for(j=0; j<n; i++){
        if(a[m] > a[j]){
            m=j;
        }
    }
    t=a[0]; //swap
    a[0]-a[m];
    a[m]=t;

    sort(a+1, n-1);
    return;
}
```

## proof by Invariant

집합 조건을 깰 수 있는 코드는 지금도 없음

Base : n=1 할 일이 없음 => True

Step : 

n-1일 때, sort함수가 성공한다면

=> 즉, 재귀 호출이 끝난 후 a[1] < a[2]< ... < a[n-1]이라면

n일때 sort함수가 성공한다.

=> 함수가 끝날 때 a[0] < a[1] < ... < a[n-1]

재귀 호출 전 a[0]은 MIN이고 a[0] < a[1] , ... , a[0]< a[n-1]이 성립한다.

**결론적으로 재귀 호출로 인해 1~n-1이 sort가 되어있고 a[0] < a[1]이 자명하므로(a[1] a[0]이 아닌 a[1] or a[2] or ,... a[n-1]이기 때문에)
0~n-1은 sort된다.**


## 2주차

